{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducci\u00f3n El presente material establece una gu\u00eda sobre como inicializar, configurar, verificar e implementar una capa de acceso a datos para los proyectos backend de APSYS. Para ejemplificar de manera pr\u00e1ctica, se desarrollar\u00e1 el c\u00f3digo requerido para un proyecto llamado bookstore Arquitectura de un backend Las aplicaciones de backend desarrolladas generalmente siguen un organizaci\u00f3n de capas como la que se muestra en la imagen a continuaci\u00f3n Esta gu\u00eda explica como realizar la implementaci\u00f3n usando los patrones de dise\u00f1o unitOfWork y repository . Para mayor documentaci\u00f3n sobre estos patrones de dise\u00f1o, puedes consultar las referencias: https://martinfowler.com/eaaCatalog/unitOfWork.html https://martinfowler.com/eaaCatalog/repository.html Inicializaci\u00f3n de un proyecto Crea una soluci\u00f3n en blanco usando Visual Studio 2017 o 2019, con el nombre apsys.training.bookstore.sln . Dentro de esa soluci\u00f3n agrega los siguientes proyecto, organizados como se muestra a continuaci\u00f3n Proyecto Tipo de proyecto Carpeta apsys.training.bookstore Biblioteca de clases 02.domain apsys.training.bookstore.repositories Biblioteca de clases 01.data apsys.training.bookstore.repositories.nhibernate Biblioteca de clases 01.data apsys.training.bookstore.repositories.testing NUnit 01.data apsys.training.bookstore.migrations Aplicaci\u00f3n de consola 00.tools Definici\u00f3n del dominio La capa de datos se encarga de persistir y recuperar nuestras entidades del dominio de una base de datos, por lo que necesitamos de primera instancia entidades en nuestro dominio. Agrega las siguientes clases a el proyecto apsys.training.bookstore public class Author { public string Id { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public IEnumerable<Book> Books { get; set; } } public class Book { public string Id { get; set; } public string Title { get; set; } public string ISBN { get; set; } public string Genre { get; set; } public DateTime PublishDate { get; set; } public Author Author { get; set; } }","title":"Introducci\u00f3n"},{"location":"#introduccion","text":"El presente material establece una gu\u00eda sobre como inicializar, configurar, verificar e implementar una capa de acceso a datos para los proyectos backend de APSYS. Para ejemplificar de manera pr\u00e1ctica, se desarrollar\u00e1 el c\u00f3digo requerido para un proyecto llamado bookstore","title":"Introducci\u00f3n"},{"location":"#arquitectura-de-un-backend","text":"Las aplicaciones de backend desarrolladas generalmente siguen un organizaci\u00f3n de capas como la que se muestra en la imagen a continuaci\u00f3n Esta gu\u00eda explica como realizar la implementaci\u00f3n usando los patrones de dise\u00f1o unitOfWork y repository . Para mayor documentaci\u00f3n sobre estos patrones de dise\u00f1o, puedes consultar las referencias: https://martinfowler.com/eaaCatalog/unitOfWork.html https://martinfowler.com/eaaCatalog/repository.html","title":"Arquitectura de un backend"},{"location":"#inicializacion-de-un-proyecto","text":"Crea una soluci\u00f3n en blanco usando Visual Studio 2017 o 2019, con el nombre apsys.training.bookstore.sln . Dentro de esa soluci\u00f3n agrega los siguientes proyecto, organizados como se muestra a continuaci\u00f3n Proyecto Tipo de proyecto Carpeta apsys.training.bookstore Biblioteca de clases 02.domain apsys.training.bookstore.repositories Biblioteca de clases 01.data apsys.training.bookstore.repositories.nhibernate Biblioteca de clases 01.data apsys.training.bookstore.repositories.testing NUnit 01.data apsys.training.bookstore.migrations Aplicaci\u00f3n de consola 00.tools","title":"Inicializaci\u00f3n de un proyecto"},{"location":"#definicion-del-dominio","text":"La capa de datos se encarga de persistir y recuperar nuestras entidades del dominio de una base de datos, por lo que necesitamos de primera instancia entidades en nuestro dominio. Agrega las siguientes clases a el proyecto apsys.training.bookstore public class Author { public string Id { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public IEnumerable<Book> Books { get; set; } } public class Book { public string Id { get; set; } public string Title { get; set; } public string ISBN { get; set; } public string Genre { get; set; } public DateTime PublishDate { get; set; } public Author Author { get; set; } }","title":"Definici\u00f3n del dominio"},{"location":"managing_database_schema/","text":"Esquema de la base de datos El esquema de la base de datos, igual que cualquier otro elemento en el desarrollo de un proyecto, debe ser mantenida bajo un estricto control de versiones. Esta guia indica como gestionar cada cambio en la base de datos, de forma que se garantize la integridad entre la aplicaci\u00f3n y el esquema de la base de datos que almacena la informaci\u00f3n, asi como la distribuci\u00f3n de los cambios en las tablas, campos, llaves, etc en los diferentes ambientes de trabajo, de pruebas y producci\u00f3n Creaci\u00f3n de la base de datos Para persistir la informaci\u00f3n, en esta gu\u00eda usaremos Microsoft SQL Server Express sin embargo cualquier base de datos relacional, como MySQL , Postgress , pueden ser usadas, realizando los ajustes requeridos en la configuraci\u00f3n Usando Microsoft SQL Server Management Studio , crea una base de datos con el nombre BookStore Creaci\u00f3n del esquema de datos Ahora podemos crear las tablas en nuestra base de datos. Para mantener el esquema de la base de datos bajo control de versiones, usaremos una herramienta llamada Migrator.NET, asi como una serie de paquetes relacionados Abre el proyecto apsys.training.bookstore.migrations e instala los siguientes paquetes Install-Package FluentMigrator -Version 3.3.1 Install-Package FluentMigrator.Extensions.SqlServer -Version 3.3.1 Install-Package FluentMigrator.Runner -Version 3.3.1 Agregar tabla Authors Vamos a crear una tabla para almacenar la informaci\u00f3n de la entidad Author . En el proyecto apsys.training.bookstore.migrations , agrega una clase llamada M01_CreateAuthorsTable como se muestra a continuaci\u00f3n [Migration(1)] public class M01_CreateAuthorsTable: Migration { public override void Up() { Create.Table(\"Authors\") .WithColumn(\"Id\").AsString().PrimaryKey() .WithColumn(\"FirstName\").AsString().NotNullable() .WithColumn(\"LastName\").AsString().NotNullable(); } public override void Down() { Delete.Table(\"Authors\"); } } Como observas la clase tiene el atributo [Migration(1)] . Este atributo estable un n\u00famero consecutivo, no repetido de migraci\u00f3n. En caso de omitir este atributo, la migraci\u00f3n no se ejecutar\u00e1 El m\u00e9todo Up deber\u00e1 contener los cambios a realizar en nuestro esquema de la base de datos. En este caso, agregamos una tabla llamada Authors con sus campos correspondientes. El m\u00e9todo Down deber\u00e1 contener el c\u00f3digo que permita deshacer los cambios realizados en el m\u00e9todo Up . En este caso, la eliminaci\u00f3n de la tabla Authors Todo cambio en el esquema de la base de datos deber\u00e1 ser realizado a trav\u00e9s de una migraci\u00f3n. Jam\u00e1s se deber\u00e1n hacer cambios manualmente, porque el resto de los ambientes de trabajo, pruebas o producci\u00f3n no podr\u00e1n ser actualizados correctamente Ejecutando las migraciones Para ver reflejados los cambios en nuestra base de datos, debemos ejecutar nuestras migraciones. Abre el archivo Program.cs del proyecto de migraciones y escribe el siguiente c\u00f3digo public class Program { static int Main() { try { CommandLineArgs parameter = new CommandLineArgs(); if (!parameter.ContainsKey(\"cnn\")) throw new ArgumentException(\"No [cnn] parameter received. You need pass the connection string in order to execute the migrations\"); string connectionString = parameter[\"cnn\"]; var serviceProvider = CreateServices(connectionString); using var scope = serviceProvider.CreateScope(); UpdateDatabase(scope.ServiceProvider); return (int)ExitCode.Success; } catch (Exception ex) { Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine($\"Error updating the database schema: {ex.Message}\"); Console.ResetColor(); return (int)ExitCode.UnknownError; } } private static IServiceProvider CreateServices(string connectionString) { return new ServiceCollection() .AddFluentMigratorCore() .ConfigureRunner(rb => rb .AddSqlServer2016() .WithGlobalConnectionString(connectionString) .ScanIn(typeof(M01_CreateAuthorsTable).Assembly).For.Migrations()) .AddLogging(lb => lb.AddFluentMigratorConsole()) .BuildServiceProvider(false); } private static void UpdateDatabase(IServiceProvider serviceProvider) { var runner = serviceProvider.GetRequiredService<IMigrationRunner>(); runner.MigrateUp(); } } enum ExitCode { Success = 0, UnknownError = 1 } class CommandLineArgs : Dictionary<string, string> { private const string Pattern = @\"\\/(?<argname>\\w+):(?<argvalue>.+)\"; private readonly Regex _regex = new Regex(Pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled); public CommandLineArgs() { var args = Environment.GetCommandLineArgs(); foreach (var match in args.Select(arg => _regex.Match(arg)).Where(m => m.Success)) this.Add(match.Groups[\"argname\"].Value, match.Groups[\"argvalue\"].Value); } } Una vez modificado el c\u00f3digo y compilado, inicializa una terminar en la ruta donde se encuentra el archivo ejecutable de las migraciones. Normalmente estar\u00e1 localizado en la carpeta ...\\bookstore\\src\\apsys.training.bookstore.migrations\\bin\\Debug\\netcoreapp3.1 Ejecuta las migraciones de la siguiente manera: apsys.training.bookstore.migrations.exe /cnn:\"Server=localhost\\SQLEXPRESS;Database=BookStore;Trusted_Connection=True;\" El valor de la propiedad Server puede cambiar dependiendo de tu instalacion de SQL Server","title":"Esquema de base de datos"},{"location":"managing_database_schema/#esquema-de-la-base-de-datos","text":"El esquema de la base de datos, igual que cualquier otro elemento en el desarrollo de un proyecto, debe ser mantenida bajo un estricto control de versiones. Esta guia indica como gestionar cada cambio en la base de datos, de forma que se garantize la integridad entre la aplicaci\u00f3n y el esquema de la base de datos que almacena la informaci\u00f3n, asi como la distribuci\u00f3n de los cambios en las tablas, campos, llaves, etc en los diferentes ambientes de trabajo, de pruebas y producci\u00f3n","title":"Esquema de la base de datos"},{"location":"managing_database_schema/#creacion-de-la-base-de-datos","text":"Para persistir la informaci\u00f3n, en esta gu\u00eda usaremos Microsoft SQL Server Express sin embargo cualquier base de datos relacional, como MySQL , Postgress , pueden ser usadas, realizando los ajustes requeridos en la configuraci\u00f3n Usando Microsoft SQL Server Management Studio , crea una base de datos con el nombre BookStore","title":"Creaci\u00f3n de la base de datos"},{"location":"managing_database_schema/#creacion-del-esquema-de-datos","text":"Ahora podemos crear las tablas en nuestra base de datos. Para mantener el esquema de la base de datos bajo control de versiones, usaremos una herramienta llamada Migrator.NET, asi como una serie de paquetes relacionados Abre el proyecto apsys.training.bookstore.migrations e instala los siguientes paquetes Install-Package FluentMigrator -Version 3.3.1 Install-Package FluentMigrator.Extensions.SqlServer -Version 3.3.1 Install-Package FluentMigrator.Runner -Version 3.3.1","title":"Creaci\u00f3n del esquema de datos"},{"location":"managing_database_schema/#agregar-tabla-authors","text":"Vamos a crear una tabla para almacenar la informaci\u00f3n de la entidad Author . En el proyecto apsys.training.bookstore.migrations , agrega una clase llamada M01_CreateAuthorsTable como se muestra a continuaci\u00f3n [Migration(1)] public class M01_CreateAuthorsTable: Migration { public override void Up() { Create.Table(\"Authors\") .WithColumn(\"Id\").AsString().PrimaryKey() .WithColumn(\"FirstName\").AsString().NotNullable() .WithColumn(\"LastName\").AsString().NotNullable(); } public override void Down() { Delete.Table(\"Authors\"); } } Como observas la clase tiene el atributo [Migration(1)] . Este atributo estable un n\u00famero consecutivo, no repetido de migraci\u00f3n. En caso de omitir este atributo, la migraci\u00f3n no se ejecutar\u00e1 El m\u00e9todo Up deber\u00e1 contener los cambios a realizar en nuestro esquema de la base de datos. En este caso, agregamos una tabla llamada Authors con sus campos correspondientes. El m\u00e9todo Down deber\u00e1 contener el c\u00f3digo que permita deshacer los cambios realizados en el m\u00e9todo Up . En este caso, la eliminaci\u00f3n de la tabla Authors Todo cambio en el esquema de la base de datos deber\u00e1 ser realizado a trav\u00e9s de una migraci\u00f3n. Jam\u00e1s se deber\u00e1n hacer cambios manualmente, porque el resto de los ambientes de trabajo, pruebas o producci\u00f3n no podr\u00e1n ser actualizados correctamente","title":"Agregar tabla Authors"},{"location":"managing_database_schema/#ejecutando-las-migraciones","text":"Para ver reflejados los cambios en nuestra base de datos, debemos ejecutar nuestras migraciones. Abre el archivo Program.cs del proyecto de migraciones y escribe el siguiente c\u00f3digo public class Program { static int Main() { try { CommandLineArgs parameter = new CommandLineArgs(); if (!parameter.ContainsKey(\"cnn\")) throw new ArgumentException(\"No [cnn] parameter received. You need pass the connection string in order to execute the migrations\"); string connectionString = parameter[\"cnn\"]; var serviceProvider = CreateServices(connectionString); using var scope = serviceProvider.CreateScope(); UpdateDatabase(scope.ServiceProvider); return (int)ExitCode.Success; } catch (Exception ex) { Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine($\"Error updating the database schema: {ex.Message}\"); Console.ResetColor(); return (int)ExitCode.UnknownError; } } private static IServiceProvider CreateServices(string connectionString) { return new ServiceCollection() .AddFluentMigratorCore() .ConfigureRunner(rb => rb .AddSqlServer2016() .WithGlobalConnectionString(connectionString) .ScanIn(typeof(M01_CreateAuthorsTable).Assembly).For.Migrations()) .AddLogging(lb => lb.AddFluentMigratorConsole()) .BuildServiceProvider(false); } private static void UpdateDatabase(IServiceProvider serviceProvider) { var runner = serviceProvider.GetRequiredService<IMigrationRunner>(); runner.MigrateUp(); } } enum ExitCode { Success = 0, UnknownError = 1 } class CommandLineArgs : Dictionary<string, string> { private const string Pattern = @\"\\/(?<argname>\\w+):(?<argvalue>.+)\"; private readonly Regex _regex = new Regex(Pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled); public CommandLineArgs() { var args = Environment.GetCommandLineArgs(); foreach (var match in args.Select(arg => _regex.Match(arg)).Where(m => m.Success)) this.Add(match.Groups[\"argname\"].Value, match.Groups[\"argvalue\"].Value); } } Una vez modificado el c\u00f3digo y compilado, inicializa una terminar en la ruta donde se encuentra el archivo ejecutable de las migraciones. Normalmente estar\u00e1 localizado en la carpeta ...\\bookstore\\src\\apsys.training.bookstore.migrations\\bin\\Debug\\netcoreapp3.1 Ejecuta las migraciones de la siguiente manera: apsys.training.bookstore.migrations.exe /cnn:\"Server=localhost\\SQLEXPRESS;Database=BookStore;Trusted_Connection=True;\" El valor de la propiedad Server puede cambiar dependiendo de tu instalacion de SQL Server","title":"Ejecutando las migraciones"},{"location":"testing_unit_of_work/","text":"Testing del UnitOfWork Testing unit of work Install-Package FluentAssertions Install-Package NUnit Install-Package NUnit3TestAdapter","title":"Testing de UnitOfWork"},{"location":"testing_unit_of_work/#testing-del-unitofwork","text":"","title":"Testing del UnitOfWork"},{"location":"testing_unit_of_work/#testing-unit-of-work","text":"Install-Package FluentAssertions Install-Package NUnit Install-Package NUnit3TestAdapter","title":"Testing unit of work"},{"location":"unit_of_work/","text":"UnitOfWork y Repositories Ahora que tenemos un dominio, y un esquema de base de datos, necesitamos crear los elementos que nos permitan realizar las operaciones de almacenamiento y lectura de nuestras entidades la base de datos Esta guia explica como implementar el UnitOfWork usando el ORM NHibernate , que por su madurez y versatilidad a sigo la opci\u00f3n por default en los proyectos de APSYS. Sin embargo, la implementaci\u00f3n del UnitOfWork puede realizarse con otros ORM's como Microsoft Entity Framework, o incluso sin el uso de ORM alguno, generando las sentencias SQL directamente en c\u00f3digo o a trav\u00e9s de procedimientos almacenados Definici\u00f3n de UnitOfWork El primer paso consiste en crear las interfaces que definir\u00e1n las operaciones de nuestras entidades hacia la base de datos. Abre el proyecto apsys.training.bookstore.repositories.csproj e instala los siguientes paquetes Install-Package apsys.repository.core Posteriormente, definiremos la interface de nuestro UnitOfWork como se muestra a continuaci\u00f3n public interface IUnitOfWork { void Commit(); void Rollback(); } Esta primer definici\u00f3n solo contiene los m\u00e9todos que nos permitir\u00e1 ejecutar la transacci\u00f3n de los cambios realizados en todas nuestras entidades de manera at\u00f3mica, consistente y perdurable, o por el contrario, revertirlos en caso de un error Definici\u00f3n de AuthorsRepository Ahora agregaremos la definicion de nuestro primer repositorio que se encargar\u00e1 de realizar las operaciones CRUD de la entidad Authors en la base de datos public interface IAuthorsRepository: IRepository<Author> { } Como podr\u00e1s observar, IAuthorsRepository hereda de la interface IRepository<T> , contenida en el paquete apsys.repository.core . Esta interface IRepository ha sido dise\u00f1ada para definir las operaciones CRUD b\u00e1sicas como Add , Remove , Get y deber\u00e1 ser usada en todos los repositorios de nuestra aplicaci\u00f3n La interface IRepository define un tipo de dato gen\u00e9rico <T> para encapsular la definici\u00f3n de cualquier entidad de cualquier dominio. Para mayor informaci\u00f3n puede consultar la referencia https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics Una vez definido nuestro primer repositorio es necesario incluirlo en nuestro UnitOfWork . Abre el archivo IUnitOfWork.cs y modifica como se muestra a continuaci\u00f3n public interface IUnitOfWork { IAuthorsRepository Authors { get; } void Commit(); void Rollback(); } Nota que la declaraci\u00f3n de la propiedad Authors en IUnitOfWork es read-only UnitOfWork con NHibernate Con la definici\u00f3n de nuestras interfaces, podemos realizar la implementaci\u00f3n usando NHibernate. Para eso necesitamos abrir el proyecto apsys.training.bookstore.repositories.nhibernate e instalar los siguientes paquetes Install-Package apsys.repository.core Install-Package apsys.repository.nhibernate.core Install-Package NHibernate Install-Package FluentNHibernate Agrega una clase llamada UnitOfWork.cs y realiza la implementaci\u00f3n de la inteface IUnitOfWork como se muestra a continuaci\u00f3n public class UnitOfWork: IUnitOfWork { private readonly ISession _session; private ITransaction _transaction; public UnitOfWork(ISession session) { _session = session; this._transaction = session.BeginTransaction(); } public IAuthorsRepository Authors { get; } public void Commit() { if (this._transaction != null && this._transaction.IsActive) this._transaction.Commit(); else throw new TransactionException(\"The actual transaction is not longer active\"); } public void Rollback() { if (this._transaction != null && this._transaction.IsActive) this._transaction.Rollback(); else throw new TransactionException(\"The actual transaction is not longer active\"); } } Nota que en el constructor recibe una entidad de tipo ISession . Esta entidad pertenece a NHibernate e implementa a su vez el patr\u00f3n de UnitOfWork. Nuestros repositorios usar\u00e1n esta entidad para realizar todas sus operaciones hacia la base de datos https://nhibernate.info/doc/nhibernate-reference/architecture.html AuthorsRepository con NHibernate Crea una clase llamada AuthorsRepository e implementa IAuthorsRepository como se muestra a continuaci\u00f3n public class AuthorsRepository: Repository<Author>, IAuthorsRepository { public AuthorsRepository(ISession session) : base(session) { } } Nota que la clase AuthorsRepository hereda de la clase Repository<T> contenida en el paquete apsys.repository.nhibernate.core . Esta clase Repository implementa las operaciones CRUD usando la sesi\u00f3n de NHibernate Una vez definida nuestro repositorio, debemos inicializarlo en el UnitOfWork. Abre el archivo UnitOfWork.cs y modificalo como se muestra a continuaci\u00f3n public class UnitOfWork: IUnitOfWork { ... public UnitOfWork(ISession session) { _session = session; this._transaction = session.BeginTransaction(); this.Authors = new AuthorsRepository(this._session); } ... } Mapper de Author NHibernate necesita saber como mapear nuestras entidades de dominio contra la base de datos. Este mapeo lo realizamos a trav\u00e9s de clases que heredan de ClassMapping Abre el proyecto apsys.training.bookstore.repositories.nhibernate y agrega una carpeta llamada mappers . Dentro de esta carpeta agrega una clase llamada AuthorsMappers e implementa como se muestra a continuaci\u00f3n public class AuthorsMappers: ClassMapping<Author> { public AuthorsMappers() { Table(\"ApplicationRoles\"); Id(x => x.Id, x => { x.Generator(Generators.Assigned); x.Column(\"Id\"); }); Property(x => x.FirstName, x => { x.Column(\"FirstName\"); }); Property(x => x.LastName, x => { x.Column(\"LastName\"); }); } }","title":"UnitOfWork y Repositories"},{"location":"unit_of_work/#unitofwork-y-repositories","text":"Ahora que tenemos un dominio, y un esquema de base de datos, necesitamos crear los elementos que nos permitan realizar las operaciones de almacenamiento y lectura de nuestras entidades la base de datos Esta guia explica como implementar el UnitOfWork usando el ORM NHibernate , que por su madurez y versatilidad a sigo la opci\u00f3n por default en los proyectos de APSYS. Sin embargo, la implementaci\u00f3n del UnitOfWork puede realizarse con otros ORM's como Microsoft Entity Framework, o incluso sin el uso de ORM alguno, generando las sentencias SQL directamente en c\u00f3digo o a trav\u00e9s de procedimientos almacenados","title":"UnitOfWork y Repositories"},{"location":"unit_of_work/#definicion-de-unitofwork","text":"El primer paso consiste en crear las interfaces que definir\u00e1n las operaciones de nuestras entidades hacia la base de datos. Abre el proyecto apsys.training.bookstore.repositories.csproj e instala los siguientes paquetes Install-Package apsys.repository.core Posteriormente, definiremos la interface de nuestro UnitOfWork como se muestra a continuaci\u00f3n public interface IUnitOfWork { void Commit(); void Rollback(); } Esta primer definici\u00f3n solo contiene los m\u00e9todos que nos permitir\u00e1 ejecutar la transacci\u00f3n de los cambios realizados en todas nuestras entidades de manera at\u00f3mica, consistente y perdurable, o por el contrario, revertirlos en caso de un error","title":"Definici\u00f3n de UnitOfWork"},{"location":"unit_of_work/#definicion-de-authorsrepository","text":"Ahora agregaremos la definicion de nuestro primer repositorio que se encargar\u00e1 de realizar las operaciones CRUD de la entidad Authors en la base de datos public interface IAuthorsRepository: IRepository<Author> { } Como podr\u00e1s observar, IAuthorsRepository hereda de la interface IRepository<T> , contenida en el paquete apsys.repository.core . Esta interface IRepository ha sido dise\u00f1ada para definir las operaciones CRUD b\u00e1sicas como Add , Remove , Get y deber\u00e1 ser usada en todos los repositorios de nuestra aplicaci\u00f3n La interface IRepository define un tipo de dato gen\u00e9rico <T> para encapsular la definici\u00f3n de cualquier entidad de cualquier dominio. Para mayor informaci\u00f3n puede consultar la referencia https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics Una vez definido nuestro primer repositorio es necesario incluirlo en nuestro UnitOfWork . Abre el archivo IUnitOfWork.cs y modifica como se muestra a continuaci\u00f3n public interface IUnitOfWork { IAuthorsRepository Authors { get; } void Commit(); void Rollback(); } Nota que la declaraci\u00f3n de la propiedad Authors en IUnitOfWork es read-only","title":"Definici\u00f3n de AuthorsRepository"},{"location":"unit_of_work/#unitofwork-con-nhibernate","text":"Con la definici\u00f3n de nuestras interfaces, podemos realizar la implementaci\u00f3n usando NHibernate. Para eso necesitamos abrir el proyecto apsys.training.bookstore.repositories.nhibernate e instalar los siguientes paquetes Install-Package apsys.repository.core Install-Package apsys.repository.nhibernate.core Install-Package NHibernate Install-Package FluentNHibernate Agrega una clase llamada UnitOfWork.cs y realiza la implementaci\u00f3n de la inteface IUnitOfWork como se muestra a continuaci\u00f3n public class UnitOfWork: IUnitOfWork { private readonly ISession _session; private ITransaction _transaction; public UnitOfWork(ISession session) { _session = session; this._transaction = session.BeginTransaction(); } public IAuthorsRepository Authors { get; } public void Commit() { if (this._transaction != null && this._transaction.IsActive) this._transaction.Commit(); else throw new TransactionException(\"The actual transaction is not longer active\"); } public void Rollback() { if (this._transaction != null && this._transaction.IsActive) this._transaction.Rollback(); else throw new TransactionException(\"The actual transaction is not longer active\"); } } Nota que en el constructor recibe una entidad de tipo ISession . Esta entidad pertenece a NHibernate e implementa a su vez el patr\u00f3n de UnitOfWork. Nuestros repositorios usar\u00e1n esta entidad para realizar todas sus operaciones hacia la base de datos https://nhibernate.info/doc/nhibernate-reference/architecture.html","title":"UnitOfWork con NHibernate"},{"location":"unit_of_work/#authorsrepository-con-nhibernate","text":"Crea una clase llamada AuthorsRepository e implementa IAuthorsRepository como se muestra a continuaci\u00f3n public class AuthorsRepository: Repository<Author>, IAuthorsRepository { public AuthorsRepository(ISession session) : base(session) { } } Nota que la clase AuthorsRepository hereda de la clase Repository<T> contenida en el paquete apsys.repository.nhibernate.core . Esta clase Repository implementa las operaciones CRUD usando la sesi\u00f3n de NHibernate Una vez definida nuestro repositorio, debemos inicializarlo en el UnitOfWork. Abre el archivo UnitOfWork.cs y modificalo como se muestra a continuaci\u00f3n public class UnitOfWork: IUnitOfWork { ... public UnitOfWork(ISession session) { _session = session; this._transaction = session.BeginTransaction(); this.Authors = new AuthorsRepository(this._session); } ... }","title":"AuthorsRepository con NHibernate"},{"location":"unit_of_work/#mapper-de-author","text":"NHibernate necesita saber como mapear nuestras entidades de dominio contra la base de datos. Este mapeo lo realizamos a trav\u00e9s de clases que heredan de ClassMapping Abre el proyecto apsys.training.bookstore.repositories.nhibernate y agrega una carpeta llamada mappers . Dentro de esta carpeta agrega una clase llamada AuthorsMappers e implementa como se muestra a continuaci\u00f3n public class AuthorsMappers: ClassMapping<Author> { public AuthorsMappers() { Table(\"ApplicationRoles\"); Id(x => x.Id, x => { x.Generator(Generators.Assigned); x.Column(\"Id\"); }); Property(x => x.FirstName, x => { x.Column(\"FirstName\"); }); Property(x => x.LastName, x => { x.Column(\"LastName\"); }); } }","title":"Mapper de Author"}]}